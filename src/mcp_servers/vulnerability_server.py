"""
Vulnerability Agent MCP Server - "Exploit Research at Your Service"

This server provides vulnerability assessment and exploitation tools for the Kali Agents system.
It exposes sqlmap, nuclei, searchsploit, and metasploit as MCP tools.

‚ö†Ô∏è AUTHORIZED USE ONLY ‚ö†Ô∏è
These tools must only be used on systems you own or have explicit written permission to test.
"""

import subprocess
import json
import re
from typing import Dict, List, Any, Optional
from pathlib import Path
import asyncio

from fastmcp import FastMCP, Context
from src.config.settings import KALI_TOOLS, NETWORK_CONFIG, METASPLOIT_CONFIG


# Create the MCP server instance
mcp = FastMCP("VulnerabilityAgent")


@mcp.tool
async def sqlmap_scan(
    target: str,
    data: Optional[str] = None,
    cookie: Optional[str] = None,
    level: int = 1,
    risk: int = 1,
    batch: bool = True,
    ctx: Optional[Context] = None
) -> Dict[str, Any]:
    """
    Perform SQL injection testing using sqlmap.

    ‚ö†Ô∏è AUTHORIZED TESTING ONLY

    Args:
        target: Target URL to test (e.g., "http://example.com/page.php?id=1")
        data: POST data (e.g., "username=admin&password=test")
        cookie: Cookie values to use
        level: Detection level (1-5, higher = more tests)
        risk: Risk level (1-3, higher = more invasive)
        batch: Run in batch mode (no user interaction)

    Returns:
        Dictionary containing injection results, vulnerable parameters, database info

    Security:
        - URL validation prevents command injection
        - Timeout enforced to prevent DoS
        - No shell=True in subprocess
    """
    if ctx:
        await ctx.info(f"üéØ Starting sqlmap scan on {target}")

    # Security: Validate URL format
    if not target.startswith(("http://", "https://")):
        return {
            "status": "failed",
            "error": "Invalid URL: must start with http:// or https://",
            "target": target
        }

    # Security: Validate level and risk are in allowed ranges
    if not (1 <= level <= 5):
        return {"status": "failed", "error": "Level must be between 1-5"}
    if not (1 <= risk <= 3):
        return {"status": "failed", "error": "Risk must be between 1-3"}

    # Build sqlmap command (NEVER use shell=True)
    sqlmap_cmd = [
        KALI_TOOLS["sqlmap"],
        "-u", target,
        "--level", str(level),
        "--risk", str(risk),
        "--output-dir", "/tmp/sqlmap_output"
    ]

    # Add optional parameters
    if data:
        # Security: Data passed as separate argument, not in command string
        sqlmap_cmd.extend(["--data", data])

    if cookie:
        # Security: Cookie passed as separate argument
        sqlmap_cmd.extend(["--cookie", cookie])

    if batch:
        sqlmap_cmd.append("--batch")

    # Add safety options
    sqlmap_cmd.extend([
        "--threads", "4",  # Limit threads
        "--technique", "BEUST",  # All techniques
        "--random-agent"  # Randomize user agent
    ])

    try:
        if ctx:
            await ctx.info(f"üîß Executing: sqlmap on {target} (level={level}, risk={risk})")

        # Execute sqlmap command (subprocess array, not string)
        result = subprocess.run(
            sqlmap_cmd,
            capture_output=True,
            text=True,
            timeout=NETWORK_CONFIG["default_timeout"] * 20  # Extended timeout for sqlmap
        )

        # Parse sqlmap output
        scan_results = _parse_sqlmap_output(result.stdout, result.stderr)
        scan_results["target"] = target
        scan_results["level"] = level
        scan_results["risk"] = risk
        scan_results["command_used"] = " ".join(sqlmap_cmd)

        if ctx:
            vuln_count = len(scan_results.get("vulnerabilities", []))
            await ctx.info(f"‚úÖ SQLMap scan completed! Found {vuln_count} potential vulnerabilities")

        return scan_results

    except subprocess.TimeoutExpired:
        if ctx:
            await ctx.error("‚è∞ SQLMap scan timeout")
        return {
            "status": "timeout",
            "error": "Scan exceeded timeout limit",
            "target": target
        }
    except Exception as e:
        if ctx:
            await ctx.error(f"‚ùå SQLMap scan error: {str(e)}")
        return {
            "status": "failed",
            "error": str(e),
            "target": target
        }


@mcp.tool
async def nuclei_scan(
    target: str,
    templates: Optional[List[str]] = None,
    severity: Optional[List[str]] = None,
    tags: Optional[List[str]] = None,
    ctx: Optional[Context] = None
) -> Dict[str, Any]:
    """
    Perform vulnerability scanning using nuclei templates.

    ‚ö†Ô∏è AUTHORIZED TESTING ONLY

    Args:
        target: Target URL or IP to scan
        templates: Specific template IDs to use (e.g., ["cves/2021/", "vulnerabilities/"])
        severity: Filter by severity (critical, high, medium, low, info)
        tags: Filter by tags (e.g., ["rce", "sqli", "xss"])

    Returns:
        Dictionary containing discovered vulnerabilities with details
    """
    if ctx:
        await ctx.info(f"üéØ Starting nuclei scan on {target}")

    # Check if nuclei is available
    nuclei_path = "/usr/bin/nuclei"
    if not Path(nuclei_path).exists():
        return {
            "status": "failed",
            "error": "nuclei not found. Install with: go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest",
            "target": target
        }

    # Build nuclei command (subprocess array, not string)
    nuclei_cmd = [
        nuclei_path,
        "-target", target,
        "-json",  # JSON output for parsing
        "-stats",  # Show statistics
        "-silent"  # Reduce noise
    ]

    # Add template filters
    if templates:
        for template in templates:
            nuclei_cmd.extend(["-t", template])

    # Add severity filters
    if severity:
        nuclei_cmd.extend(["-severity", ",".join(severity)])

    # Add tag filters
    if tags:
        nuclei_cmd.extend(["-tags", ",".join(tags)])

    try:
        if ctx:
            await ctx.info(f"üîß Executing: nuclei scan on {target}")

        result = subprocess.run(
            nuclei_cmd,
            capture_output=True,
            text=True,
            timeout=NETWORK_CONFIG["default_timeout"] * 10
        )

        # Parse nuclei JSON output
        scan_results = _parse_nuclei_output(result.stdout)
        scan_results["target"] = target
        scan_results["filters"] = {
            "templates": templates,
            "severity": severity,
            "tags": tags
        }

        if ctx:
            vuln_count = len(scan_results.get("vulnerabilities", []))
            await ctx.info(f"‚úÖ Nuclei scan completed! Found {vuln_count} issues")

        return scan_results

    except subprocess.TimeoutExpired:
        return {
            "status": "timeout",
            "error": "Nuclei scan exceeded timeout",
            "target": target
        }
    except Exception as e:
        if ctx:
            await ctx.error(f"‚ùå Nuclei scan error: {str(e)}")
        return {
            "status": "failed",
            "error": str(e),
            "target": target
        }


@mcp.tool
async def searchsploit_query(
    query: str,
    exact: bool = False,
    json_output: bool = True,
    ctx: Optional[Context] = None
) -> Dict[str, Any]:
    """
    Search exploit database using searchsploit.

    Args:
        query: Search query (e.g., "wordpress 5.0", "apache 2.4")
        exact: Use exact match instead of fuzzy search
        json_output: Return results in JSON format

    Returns:
        Dictionary containing matching exploits with titles, paths, and descriptions
    """
    if ctx:
        await ctx.info(f"üîç Searching exploit database for: {query}")

    # Security: Validate query doesn't contain command injection attempts
    if any(char in query for char in [";", "|", "&", "`", "$", "(", ")"]):
        return {
            "status": "failed",
            "error": "Invalid query: contains potentially malicious characters",
            "query": query
        }

    # Build searchsploit command (subprocess array)
    searchsploit_cmd = [KALI_TOOLS["searchsploit"], query]

    if exact:
        searchsploit_cmd.append("--exact")

    if json_output:
        searchsploit_cmd.extend(["--json"])

    try:
        result = subprocess.run(
            searchsploit_cmd,
            capture_output=True,
            text=True,
            timeout=30
        )

        # Parse searchsploit output
        if json_output and result.stdout:
            try:
                results_data = json.loads(result.stdout)
                exploits = results_data.get("RESULTS_EXPLOIT", [])

                return {
                    "status": "completed",
                    "query": query,
                    "total_results": len(exploits),
                    "exploits": [
                        {
                            "title": exp.get("Title", ""),
                            "path": exp.get("Path", ""),
                            "date": exp.get("Date_Published", ""),
                            "author": exp.get("Author", ""),
                            "type": exp.get("Type", ""),
                            "platform": exp.get("Platform", "")
                        }
                        for exp in exploits
                    ]
                }
            except json.JSONDecodeError:
                # Fallback to text parsing
                pass

        # Text output parsing
        return _parse_searchsploit_text(result.stdout, query)

    except subprocess.TimeoutExpired:
        return {
            "status": "timeout",
            "error": "Search exceeded timeout",
            "query": query
        }
    except Exception as e:
        if ctx:
            await ctx.error(f"‚ùå SearchSploit error: {str(e)}")
        return {
            "status": "failed",
            "error": str(e),
            "query": query
        }


@mcp.tool
async def metasploit_search(
    keyword: str,
    search_type: str = "all",
    ctx: Optional[Context] = None
) -> Dict[str, Any]:
    """
    Search Metasploit modules.

    Args:
        keyword: Search keyword (e.g., "wordpress", "apache")
        search_type: Type of modules (exploit, auxiliary, payload, encoder, nop, post, all)

    Returns:
        Dictionary containing matching Metasploit modules

    Note:
        This function uses msfconsole for searching, not RPC.
        For full exploitation capabilities, use metasploit RPC separately.
    """
    if ctx:
        await ctx.info(f"üîç Searching Metasploit modules for: {keyword}")

    # Security: Validate search_type is in allowed list
    allowed_types = ["exploit", "auxiliary", "payload", "encoder", "nop", "post", "all"]
    if search_type not in allowed_types:
        return {
            "status": "failed",
            "error": f"Invalid search_type. Allowed: {allowed_types}",
            "keyword": keyword
        }

    # Security: Validate keyword
    if any(char in keyword for char in [";", "|", "&", "`", "$", "(", ")"]):
        return {
            "status": "failed",
            "error": "Invalid keyword: contains potentially malicious characters",
            "keyword": keyword
        }

    # Build msfconsole search command
    msfconsole_path = "/usr/bin/msfconsole"

    if not Path(msfconsole_path).exists():
        return {
            "status": "failed",
            "error": "msfconsole not found. Install Metasploit Framework.",
            "keyword": keyword
        }

    # Create search command
    search_cmd = f"search {keyword}"
    if search_type != "all":
        search_cmd = f"search type:{search_type} {keyword}"

    try:
        # Execute msfconsole with search command
        result = subprocess.run(
            [msfconsole_path, "-q", "-x", f"{search_cmd}; exit"],
            capture_output=True,
            text=True,
            timeout=60
        )

        # Parse msfconsole output
        modules = _parse_metasploit_search(result.stdout)

        return {
            "status": "completed",
            "keyword": keyword,
            "search_type": search_type,
            "total_results": len(modules),
            "modules": modules
        }

    except subprocess.TimeoutExpired:
        return {
            "status": "timeout",
            "error": "Metasploit search exceeded timeout",
            "keyword": keyword
        }
    except Exception as e:
        if ctx:
            await ctx.error(f"‚ùå Metasploit search error: {str(e)}")
        return {
            "status": "failed",
            "error": str(e),
            "keyword": keyword
        }


# Output Parser Functions

def _parse_sqlmap_output(stdout: str, stderr: str) -> Dict[str, Any]:
    """Parse sqlmap text output to extract vulnerability information."""
    result = {
        "status": "completed",
        "vulnerabilities": [],
        "database_info": {},
        "injection_points": []
    }

    # Check for injection found
    if "sqlmap identified the following injection point" in stdout:
        result["status"] = "vulnerable"

        # Extract injection points
        injection_pattern = r"Parameter: (.+?)\s+Type: (.+?)\s+Title: (.+?)\s+Payload: (.+?)(?:\n|$)"
        for match in re.finditer(injection_pattern, stdout, re.MULTILINE | re.DOTALL):
            result["injection_points"].append({
                "parameter": match.group(1).strip(),
                "type": match.group(2).strip(),
                "title": match.group(3).strip(),
                "payload": match.group(4).strip()
            })

    # Extract database information
    if "back-end DBMS:" in stdout:
        db_match = re.search(r"back-end DBMS:\s+(.+)", stdout)
        if db_match:
            result["database_info"]["dbms"] = db_match.group(1).strip()

    # Check if vulnerable
    if "is vulnerable" in stdout.lower() or len(result["injection_points"]) > 0:
        result["vulnerabilities"].append({
            "type": "SQL Injection",
            "severity": "critical",
            "description": "SQL injection vulnerability detected",
            "injection_points": result["injection_points"]
        })
    else:
        result["status"] = "no_vulnerabilities"

    return result


def _parse_nuclei_output(stdout: str) -> Dict[str, Any]:
    """Parse nuclei JSON output."""
    result = {
        "status": "completed",
        "vulnerabilities": []
    }

    # Nuclei outputs one JSON object per line
    for line in stdout.strip().split("\n"):
        if not line.strip():
            continue

        try:
            finding = json.loads(line)

            result["vulnerabilities"].append({
                "template_id": finding.get("templateID", ""),
                "name": finding.get("info", {}).get("name", ""),
                "severity": finding.get("info", {}).get("severity", "unknown"),
                "type": finding.get("type", ""),
                "host": finding.get("host", ""),
                "matched_at": finding.get("matched-at", ""),
                "description": finding.get("info", {}).get("description", ""),
                "reference": finding.get("info", {}).get("reference", []),
                "tags": finding.get("info", {}).get("tags", [])
            })
        except json.JSONDecodeError:
            continue

    return result


def _parse_searchsploit_text(stdout: str, query: str) -> Dict[str, Any]:
    """Parse searchsploit text output."""
    result = {
        "status": "completed",
        "query": query,
        "exploits": [],
        "total_results": 0
    }

    # Parse text table format
    lines = stdout.strip().split("\n")

    for line in lines:
        # Skip headers and separators
        if "----" in line or "Exploit Title" in line or not line.strip():
            continue

        # Parse exploit line: Title | Path
        if "|" in line:
            parts = line.split("|")
            if len(parts) >= 2:
                result["exploits"].append({
                    "title": parts[0].strip(),
                    "path": parts[1].strip()
                })

    result["total_results"] = len(result["exploits"])
    return result


def _parse_metasploit_search(stdout: str) -> List[Dict[str, Any]]:
    """Parse msfconsole search output."""
    modules = []

    lines = stdout.strip().split("\n")

    for line in lines:
        # Skip headers and empty lines
        if not line.strip() or "Name" in line or "====" in line:
            continue

        # Parse module line format: #  Name  Disclosure Date  Rank  Check  Description
        parts = re.split(r"\s{2,}", line.strip())

        if len(parts) >= 3:
            modules.append({
                "name": parts[0].strip() if len(parts) > 0 else "",
                "disclosure_date": parts[1].strip() if len(parts) > 1 else "",
                "rank": parts[2].strip() if len(parts) > 2 else "",
                "description": parts[3].strip() if len(parts) > 3 else ""
            })

    return modules


# Health check endpoint
@mcp.tool
async def health_check(ctx: Optional[Context] = None) -> Dict[str, Any]:
    """Check vulnerability server health and tool availability."""
    tools_status = {}

    # Check sqlmap
    tools_status["sqlmap"] = Path(KALI_TOOLS["sqlmap"]).exists()

    # Check searchsploit
    tools_status["searchsploit"] = Path(KALI_TOOLS["searchsploit"]).exists()

    # Check nuclei
    tools_status["nuclei"] = Path("/usr/bin/nuclei").exists()

    # Check msfconsole
    tools_status["metasploit"] = Path("/usr/bin/msfconsole").exists()

    all_available = all(tools_status.values())

    return {
        "status": "healthy" if all_available else "degraded",
        "tools": tools_status,
        "server": "VulnerabilityAgent",
        "version": "1.0.0"
    }


if __name__ == "__main__":
    # Run the MCP server
    mcp.run()
